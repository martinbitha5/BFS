"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express_1 = require("express");
const database_1 = require("../config/database");
const airport_restriction_middleware_1 = require("../middleware/airport-restriction.middleware");
const router = (0, express_1.Router)();
// #region agent log
console.log('[STATS ROUTES] Loading stats routes - recent and flights endpoints available');
// #endregion
/**
 * GET /api/v1/stats/airport/:airport
 * Statistiques pour un aéroport spécifique
 * RESTRICTION: Vérifie que l'utilisateur a accès à cet aéroport
 */
router.get('/airport/:airport', airport_restriction_middleware_1.requireAirportCode, async (req, res, next) => {
    try {
        const { airport } = req.params;
        const hasFullAccess = req.hasFullAccess;
        // Si l'aéroport demandé est ALL, ne pas filtrer par aéroport
        const today = new Date().toISOString().split('T')[0];
        const filterAirport = airport.toUpperCase() === 'ALL' && hasFullAccess;
        // Récupérer tous les passagers
        let passQuery = database_1.supabase.from('passengers').select('*');
        if (!filterAirport) {
            passQuery = passQuery.eq('airport_code', airport.toUpperCase());
        }
        const { data: passengers, error: passError } = await passQuery;
        if (passError)
            throw passError;
        // Récupérer tous les bagages
        let bagQuery = database_1.supabase.from('baggages').select('*');
        if (!filterAirport) {
            bagQuery = bagQuery.eq('airport_code', airport.toUpperCase());
        }
        const { data: baggages, error: bagError } = await bagQuery;
        if (bagError)
            throw bagError;
        // Récupérer les statuts d'embarquement (via jointure avec passengers)
        let boardQuery = database_1.supabase.from('boarding_status').select('*, passengers!inner(airport_code)');
        if (!filterAirport) {
            boardQuery = boardQuery.eq('passengers.airport_code', airport.toUpperCase());
        }
        const { data: boardingStatuses, error: boardError } = await boardQuery;
        if (boardError)
            throw boardError;
        // Calculer les statistiques
        const totalPassengers = passengers?.length || 0;
        const totalBaggages = baggages?.length || 0;
        const boardedPassengers = boardingStatuses?.filter(bs => bs.boarded).length || 0;
        const arrivedBaggages = baggages?.filter(b => b.status === 'arrived').length || 0;
        const todayPassengers = passengers?.filter(p => p.checkedInAt?.startsWith(today)).length || 0;
        const todayBaggages = baggages?.filter(b => b.checkedAt?.startsWith(today)).length || 0;
        const uniqueFlights = [...new Set(passengers?.map(p => p.flightNumber) || [])];
        res.json({
            success: true,
            data: {
                airportCode: airport,
                totalPassengers,
                totalBaggages,
                boardedPassengers,
                notBoardedPassengers: totalPassengers - boardedPassengers,
                arrivedBaggages,
                inTransitBaggages: totalBaggages - arrivedBaggages,
                todayPassengers,
                todayBaggages,
                flightsCount: uniqueFlights.length,
                uniqueFlights,
                timestamp: new Date().toISOString()
            }
        });
    }
    catch (error) {
        next(error);
    }
});
/**
 * GET /api/v1/stats/recent/:airport
 * Données récentes parsées (passagers, bagages, activités)
 * Pour affichage détaillé dans le dashboard
 */
router.get('/recent/:airport', airport_restriction_middleware_1.requireAirportCode, async (req, res, next) => {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/2e82e369-b2c3-4892-be74-bf76a361a519', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ location: 'stats.routes.ts:recent', message: 'Route /recent/:airport called', data: { airport: req.params.airport, query: req.query }, timestamp: Date.now(), sessionId: 'debug-session', hypothesisId: 'A' }) }).catch(() => { });
    // #endregion
    try {
        const { airport } = req.params;
        const limit = parseInt(req.query.limit) || 10;
        const today = new Date().toISOString().split('T')[0];
        const filterByAirport = airport.toUpperCase() !== 'ALL';
        // 1. Passagers récents (aujourd'hui) avec infos parsées
        let passQuery = database_1.supabase
            .from('passengers')
            .select(`
        id, 
        pnr, 
        full_name, 
        flight_number, 
        departure, 
        arrival, 
        baggage_count,
        checked_in_at
      `)
            .gte('checked_in_at', today)
            .order('checked_in_at', { ascending: false })
            .limit(limit);
        if (filterByAirport) {
            passQuery = passQuery.eq('airport_code', airport.toUpperCase());
        }
        const { data: recentPassengers, error: passError } = await passQuery;
        if (passError)
            throw passError;
        // 2. Bagages récents - requête simplifiée
        let bagQuery = database_1.supabase
            .from('baggages')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(limit);
        if (filterByAirport) {
            bagQuery = bagQuery.eq('airport_code', airport.toUpperCase());
        }
        const { data: recentBaggages, error: bagError } = await bagQuery;
        // Ignorer les erreurs de bagages pour ne pas bloquer la route
        if (bagError) {
            console.warn('Baggage query error:', bagError.message);
        }
        // 3. Activités récentes (audit log) - requête simplifiée
        let actQuery = database_1.supabase
            .from('audit_logs')
            .select('*')
            .order('created_at', { ascending: false })
            .limit(limit);
        if (filterByAirport) {
            actQuery = actQuery.eq('airport_code', airport.toUpperCase());
        }
        const { data: recentActivities, error: actError } = await actQuery;
        // Transformer les données pour l'affichage
        const formattedPassengers = recentPassengers?.map(p => ({
            id: p.id,
            pnr: p.pnr,
            fullName: p.full_name,
            flightNumber: p.flight_number,
            route: `${p.departure} → ${p.arrival}`,
            baggageCount: p.baggage_count || 0,
            checkedInAt: p.checked_in_at,
        })) || [];
        const formattedBaggages = recentBaggages?.map(b => ({
            id: b.id,
            tag: b.tag_number || b.rfid_tag || b.id,
            status: b.status || 'unknown',
            passengerId: b.passenger_id,
            createdAt: b.created_at,
        })) || [];
        const formattedActivities = recentActivities?.map(a => ({
            id: a.id,
            action: a.action,
            entityType: a.entity_type,
            details: a.details,
            createdAt: a.created_at,
            userId: a.user_id,
        })) || [];
        res.json({
            success: true,
            data: {
                recentPassengers: formattedPassengers,
                recentBaggages: formattedBaggages,
                recentActivities: formattedActivities,
                timestamp: new Date().toISOString()
            }
        });
    }
    catch (error) {
        next(error);
    }
});
/**
 * GET /api/v1/stats/flights/:airport
 * Vols du jour avec statistiques détaillées par vol
 */
router.get('/flights/:airport', airport_restriction_middleware_1.requireAirportCode, async (req, res, next) => {
    // #region agent log
    fetch('http://127.0.0.1:7242/ingest/2e82e369-b2c3-4892-be74-bf76a361a519', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ location: 'stats.routes.ts:flights', message: 'Route /flights/:airport called', data: { airport: req.params.airport }, timestamp: Date.now(), sessionId: 'debug-session', hypothesisId: 'A' }) }).catch(() => { });
    // #endregion
    try {
        const { airport } = req.params;
        const today = new Date().toISOString().split('T')[0];
        const filterByAirport = airport.toUpperCase() !== 'ALL';
        // Récupérer les vols programmés aujourd'hui
        let flightQuery = database_1.supabase
            .from('flight_schedule')
            .select('*')
            .eq('scheduled_date', today)
            .order('scheduled_time', { ascending: true });
        if (filterByAirport) {
            flightQuery = flightQuery.eq('airport_code', airport.toUpperCase());
        }
        const { data: scheduledFlights, error: flightError } = await flightQuery;
        if (flightError)
            throw flightError;
        // Pour chaque vol, récupérer les stats de passagers et bagages
        const flightsWithStats = await Promise.all((scheduledFlights || []).map(async (flight) => {
            // Compter les passagers de ce vol
            let passCountQuery = database_1.supabase
                .from('passengers')
                .select('*', { count: 'exact', head: true })
                .eq('flight_number', flight.flight_number);
            if (filterByAirport) {
                passCountQuery = passCountQuery.eq('airport_code', airport.toUpperCase());
            }
            const { count: passengerCount } = await passCountQuery;
            // Compter les passagers embarqués
            let boardedQuery = database_1.supabase
                .from('boarding_status')
                .select('passenger_id, passengers!inner(flight_number, airport_code)')
                .eq('boarded', true)
                .eq('passengers.flight_number', flight.flight_number);
            if (filterByAirport) {
                boardedQuery = boardedQuery.eq('passengers.airport_code', airport.toUpperCase());
            }
            const { data: boardedData } = await boardedQuery;
            // Compter les bagages de ce vol
            let bagCountQuery = database_1.supabase
                .from('baggages')
                .select('*', { count: 'exact', head: true })
                .eq('flight_number', flight.flight_number);
            if (filterByAirport) {
                bagCountQuery = bagCountQuery.eq('airport_code', airport.toUpperCase());
            }
            const { count: baggageCount } = await bagCountQuery;
            return {
                id: flight.id,
                flightNumber: flight.flight_number,
                airline: flight.airline,
                airlineCode: flight.airline_code,
                departure: flight.departure,
                arrival: flight.arrival,
                scheduledTime: flight.scheduled_time,
                status: flight.status,
                flightType: flight.flight_type || 'departure',
                baggageRestriction: flight.baggage_restriction || 'block',
                stats: {
                    totalPassengers: passengerCount || 0,
                    boardedPassengers: boardedData?.length || 0,
                    totalBaggages: baggageCount || 0,
                    boardingProgress: passengerCount ? Math.round(((boardedData?.length || 0) / passengerCount) * 100) : 0,
                }
            };
        }));
        res.json({
            success: true,
            data: {
                flights: flightsWithStats,
                totalFlights: flightsWithStats.length,
                timestamp: new Date().toISOString()
            }
        });
    }
    catch (error) {
        next(error);
    }
});
/**
 * GET /api/v1/stats/global
 * Statistiques globales de tous les aéroports
 * RESTRICTION: Réservé aux superviseurs uniquement
 */
router.get('/global', airport_restriction_middleware_1.requireAirportCode, async (req, res, next) => {
    try {
        const today = new Date().toISOString().split('T')[0];
        const { data: passengers, error: passError } = await database_1.supabase
            .from('passengers')
            .select('*');
        if (passError)
            throw passError;
        const { data: baggages, error: bagError } = await database_1.supabase
            .from('baggages')
            .select('*');
        if (bagError)
            throw bagError;
        const { data: boardingStatuses, error: boardError } = await database_1.supabase
            .from('boarding_status')
            .select('*');
        if (boardError)
            throw boardError;
        const totalPassengers = passengers?.length || 0;
        const totalBaggages = baggages?.length || 0;
        const boardedPassengers = boardingStatuses?.filter(bs => bs.boarded).length || 0;
        const arrivedBaggages = baggages?.filter(b => b.status === 'arrived').length || 0;
        const todayPassengers = passengers?.filter(p => p.checkedInAt?.startsWith(today)).length || 0;
        const todayBaggages = baggages?.filter(b => b.checkedAt?.startsWith(today)).length || 0;
        // Grouper par aéroport
        const airportStats = passengers?.reduce((acc, p) => {
            if (!acc[p.airportCode]) {
                acc[p.airportCode] = {
                    passengers: 0,
                    baggages: 0
                };
            }
            acc[p.airportCode].passengers++;
            return acc;
        }, {});
        res.json({
            success: true,
            data: {
                totalPassengers,
                totalBaggages,
                boardedPassengers,
                notBoardedPassengers: totalPassengers - boardedPassengers,
                arrivedBaggages,
                inTransitBaggages: totalBaggages - arrivedBaggages,
                todayPassengers,
                todayBaggages,
                airportStats,
                timestamp: new Date().toISOString()
            }
        });
    }
    catch (error) {
        next(error);
    }
});
exports.default = router;
